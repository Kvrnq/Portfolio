(() => {
    "use strict";

    var t = {
        d: (e, n) => {
            for (var r in n)
                if (Object.hasOwn(n, r) && !Object.hasOwn(e, r))
                    Object.defineProperty(e, r, {
                        enumerable: true,
                        get: n[r]
                    });
        },
        r: (t) => {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                Object.defineProperty(t, Symbol.toStringTag, { value: "Module" });
            }
            Object.defineProperty(t, "__esModule", { value: true });
        }
    };

    var e = {};
    t.r(e);

    t.d(e, {
        actions: () => P,
        addAction: () => A,
        addFilter: () => m,
        applyFilters: () => w,
        applyFiltersAsync: () => I,
        createHooks: () => h,
        currentAction: () => x,
        currentFilter: () => T,
        defaultHooks: () => f,
        didAction: () => j,
        didFilter: () => z,
        doAction: () => g,
        doActionAsync: () => k,
        doingAction: () => O,
        doingFilter: () => S,
        filters: () => Z,
        hasAction: () => _,
        hasFilter: () => v,
        removeAction: () => p,
        removeAllActions: () => F,
        removeAllFilters: () => b,
        removeFilter: () => y
    });

    const validateNamespace = (t) => {
        if (typeof t !== "string" || t === "") {
            console.error("❌ The namespace must be a non-empty string.");
            return false;
        }
        return /^[a-zA-Z][a-zA-Z0-9_.\-\/]*$/.test(t) || (console.error("❌ Invalid namespace: Only letters, numbers, dashes, underscores, periods, and slashes allowed."), false);
    };

    const validateHookName = (t) => {
        if (typeof t !== "string" || t === "") {
            console.error("❌ The hook name must be a non-empty string.");
            return false;
        }
        if (/^__/.test(t)) {
            console.error("❌ Hook name cannot start with '__'.");
            return false;
        }
        return /^[a-zA-Z][a-zA-Z0-9_.-]*$/.test(t) || (console.error("❌ Invalid hook name: Only letters, numbers, dashes, underscores, and periods allowed."), false);
    };

    const addHook = (hooks, type) => (hook, namespace, callback, priority = 10) => {
        if (!validateHookName(hook) || !validateNamespace(namespace) || typeof callback !== "function") {
            console.error("❌ Invalid hook parameters.");
            return;
        }
        if (typeof priority !== "number") {
            console.error("❌ Hook priority must be a number.");
            return;
        }

        const entry = { callback, priority, namespace };
        if (!hooks[type][hook]) {
            hooks[type][hook] = { handlers: [entry], runs: 0 };
        } else {
            const handlers = hooks[type][hook].handlers;
            const index = handlers.findIndex((h) => h.priority > priority);
            if (index === -1) handlers.push(entry);
            else handlers.splice(index, 0, entry);
            hooks[type].__current.forEach((t) => {
                if (t.name === hook && t.currentIndex >= index) t.currentIndex++;
            });
        }
        hooks.doAction("hookAdded", hook, namespace, callback, priority);
    };

    const removeHook = (hooks, type, removeAll = false) => (hook, namespace) => {
        if (!validateHookName(hook)) return 0;
        if (!removeAll && !validateNamespace(namespace)) return 0;

        if (!hooks[type][hook]) return 0;

        let count = 0;
        if (removeAll) {
            count = hooks[type][hook].handlers.length;
            hooks[type][hook] = { runs: hooks[type][hook].runs, handlers: [] };
        } else {
            const handlers = hooks[type][hook].handlers;
            hooks[type][hook].handlers = handlers.filter(h => h.namespace !== namespace);
            count = handlers.length - hooks[type][hook].handlers.length;
        }

        hooks.doAction("hookRemoved", hook, namespace);
        return count;
    };

    const checkHook = (hooks, type) => (hook, namespace) => {
        return namespace ? hooks[type][hook]?.handlers.some(h => h.namespace === namespace) : !!hooks[type][hook];
    };

    const executeHook = (hooks, type, returnFirst = false, asyncExecution = false) => (hook, ...args) => {
        if (!hooks[type][hook]) {
            return returnFirst ? args[0] : undefined;
        }

        hooks[type][hook].runs++;
        const handlers = hooks[type][hook].handlers;
        const context = { name: hook, currentIndex: 0 };

        const execute = async () => {
            try {
                hooks[type].__current.add(context);
                let result = returnFirst ? args[0] : undefined;
                for (; context.currentIndex < handlers.length; context.currentIndex++) {
                    result = await handlers[context.currentIndex].callback(...args);
                    if (returnFirst) args[0] = result;
                }
                return returnFirst ? result : undefined;
            } finally {
                hooks[type].__current.delete(context);
            }
        };

        return asyncExecution ? execute() : execute();
    };

    const getCurrentHook = (hooks, type) => () => {
        return [...hooks[type].__current].at(-1)?.name || null;
    };

    const isDoingHook = (hooks, type) => (hook) => {
        return hook ? [...hooks[type].__current].some(t => t.name === hook) : hooks[type].__current.size > 0;
    };

    const getHookRunCount = (hooks, type) => (hook) => {
        return hooks[type][hook]?.runs || 0;
    };

    class HookManager {
        constructor() {
            this.actions = { __current: new Set };
            this.filters = { __current: new Set };

            this.addAction = addHook(this, "actions");
            this.addFilter = addHook(this, "filters");
            this.removeAction = removeHook(this, "actions");
            this.removeFilter = removeHook(this, "filters");
            this.hasAction = checkHook(this, "actions");
            this.hasFilter = checkHook(this, "filters");
            this.removeAllActions = removeHook(this, "actions", true);
            this.removeAllFilters = removeHook(this, "filters", true);
            this.doAction = executeHook(this, "actions", false, false);
            this.doActionAsync = executeHook(this, "actions", false, true);
            this.applyFilters = executeHook(this, "filters", true, false);
            this.applyFiltersAsync = executeHook(this, "filters", true, true);
            this.currentAction = getCurrentHook(this, "actions");
            this.currentFilter = getCurrentHook(this, "filters");
            this.doingAction = isDoingHook(this, "actions");
            this.doingFilter = isDoingHook(this, "filters");
            this.didAction = getHookRunCount(this, "actions");
            this.didFilter = getHookRunCount(this, "filters");
        }
    }

    const f = new HookManager();
    (window.wp = window.wp || {}).hooks = e;
})();
