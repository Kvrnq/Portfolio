/*! This file is auto-generated */
(() => {
    "use strict";

    var t = {
        2058: (t, e, r) => {
            var n;
            (function() {
                "use strict";

                var i = {
                    not_string: /[^s]/,
                    not_bool: /[^t]/,
                    not_type: /[^T]/,
                    not_primitive: /[^v]/,
                    number: /[diefg]/,
                    numeric_arg: /[bcdiefguxX]/,
                    json: /[j]/,
                    not_json: /[^j]/,
                    text: /^[^\x25]+/,
                    modulo: /^\x25{2}/,
                    placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
                    key: /^([a-z_][a-z_\d]*)/i,
                    key_access: /^\.([a-z_][a-z_\d]*)/i,
                    index_access: /^\[(\d+)\]/,
                    sign: /^[+-]/
                };

                function formatString(t, ...e) {
                    try {
                        return e.length ? sprintf.apply(null, [t].concat(e)) : t;
                    } catch (error) {
                        console.error("❌ sprintf error: ", error);
                        return t;
                    }
                }

                function sprintf(t) {
                    return function format(t, args) {
                        var output = "",
                            position = 1,
                            length = t.length;

                        for (let i = 0; i < length; i++) {
                            if (typeof t[i] === "string") {
                                output += t[i];
                            } else if (typeof t[i] === "object") {
                                let s = t[i],
                                    value = s.keys ? args[position] : args[s.param_no || position++];
                                
                                if (s.keys) {
                                    for (let key of s.keys) {
                                        if (value == null) {
                                            throw new Error(`❌ [sprintf] Cannot access property "${key}" of undefined value.`);
                                        }
                                        value = value[key];
                                    }
                                }

                                if (i.not_type.test(s.type) && i.not_primitive.test(s.type) && value instanceof Function) {
                                    value = value();
                                }

                                if (i.numeric_arg.test(s.type) && isNaN(value)) {
                                    throw new TypeError(`❌ [sprintf] Expecting number but found ${typeof value}`);
                                }

                                let isPositive = value >= 0;
                                switch (s.type) {
                                    case "b": value = parseInt(value, 10).toString(2); break;
                                    case "c": value = String.fromCharCode(parseInt(value, 10)); break;
                                    case "d":
                                    case "i": value = parseInt(value, 10); break;
                                    case "j": value = JSON.stringify(value, null, s.width ? parseInt(s.width) : 0); break;
                                    case "e": value = s.precision ? parseFloat(value).toExponential(s.precision) : parseFloat(value).toExponential(); break;
                                    case "f": value = s.precision ? parseFloat(value).toFixed(s.precision) : parseFloat(value); break;
                                    case "g": value = s.precision ? String(Number(value.toPrecision(s.precision))) : parseFloat(value); break;
                                    case "o": value = (parseInt(value, 10) >>> 0).toString(8); break;
                                    case "s": value = String(value).substring(0, s.precision || value.length); break;
                                    case "t": value = String(!!value).substring(0, s.precision || value.length); break;
                                    case "T": value = Object.prototype.toString.call(value).slice(8, -1).toLowerCase().substring(0, s.precision || value.length); break;
                                    case "u": value = parseInt(value, 10) >>> 0; break;
                                    case "v": value = value.valueOf().substring(0, s.precision || value.length); break;
                                    case "x": value = (parseInt(value, 10) >>> 0).toString(16); break;
                                    case "X": value = (parseInt(value, 10) >>> 0).toString(16).toUpperCase(); break;
                                }

                                let sign = i.number.test(s.type) && !isPositive && s.sign ? "-" : "",
                                    padChar = s.pad_char ? (s.pad_char === "0" ? "0" : s.pad_char.charAt(1)) : " ",
                                    padding = s.width && s.width > (sign + value).length ? padChar.repeat(s.width - (sign + value).length) : "";

                                output += s.align ? sign + value + padding : (padChar === "0" ? sign + padding + value : padding + sign + value);
                            }
                        }
                        return output;
                    }(parseFormat(t), arguments);
                }

                function parseFormat(t) {
                    if (cachedFormats[t]) return cachedFormats[t];
                    
                    let format = t,
                        parsed = [],
                        pos = 0;

                    while (format) {
                        let match;
                        if ((match = i.text.exec(format))) parsed.push(match[0]);
                        else if ((match = i.modulo.exec(format))) parsed.push("%");
                        else if ((match = i.placeholder.exec(format))) {
                            if (match[2]) {
                                let keys = [],
                                    key = match[2];

                                while (key) {
                                    let keyMatch;
                                    if ((keyMatch = i.key.exec(key))) keys.push(keyMatch[1]);
                                    else if ((keyMatch = i.key_access.exec(key))) keys.push(keyMatch[1]);
                                    else if ((keyMatch = i.index_access.exec(key))) keys.push(keyMatch[1]);
                                    else throw new SyntaxError("[sprintf] Failed to parse named argument key.");
                                    
                                    key = key.substring(keyMatch[0].length);
                                }
                                match[2] = keys;
                            }
                            parsed.push({
                                placeholder: match[0],
                                param_no: match[1],
                                keys: match[2],
                                sign: match[3],
                                pad_char: match[4],
                                align: match[5],
                                width: match[6],
                                precision: match[7],
                                type: match[8]
                            });
                        } else {
                            throw new SyntaxError("[sprintf] Unexpected placeholder.");
                        }
                        format = format.substring(match[0].length);
                    }

                    return (cachedFormats[t] = parsed);
                }

                var cachedFormats = Object.create(null);
                e.sprintf = sprintf;
                e.vsprintf = (t, e) => sprintf.apply(null, [t].concat(e || []));

                if (typeof window !== "undefined") {
                    window.sprintf = sprintf;
                    window.vsprintf = e.vsprintf;
                }

                if (typeof module !== "undefined" && module.exports) {
                    module.exports = e;
                }
            })();
        }
    };

    var e = {};
    function r(n) {
        return e[n] || (e[n] = { exports: {} }, t[n](e[n], e[n].exports, r)), e[n].exports;
    }

    r.d = (t, e) => {
        for (var n in e) Object.hasOwn(e, n) && !Object.hasOwn(t, n) && Object.defineProperty(t, n, {
            enumerable: true,
            get: e[n]
        });
    };

    var n = {};
    (() => {
        "use strict";
        r.d(n, { sprintf: () => formatString });
    })();

    (window.wp = window.wp || {}).i18n = n;
})();
